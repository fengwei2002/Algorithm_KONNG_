当搜索空间非常庞大的时候，使用 astar 才有效果

搜索的基本流程:

使用优先级队列替换 BFS 中使用的队列，每次取出来优先级队列的队头  
每一个状态在存储的时候
- 存储从起点走到当前点的真实距离 d(u)
- 存储当前点到终点的估计距离 f(u)
- 使用 `d[u] + f[u]` 作为第一关键字来进行排序

```cpp
while que.size(): 
    t <- 优先级队列的队头 
      当终点第一次出队的时候 break 
    for t 的所有邻边 
        将所有的邻边入队
```

`astar` 可以处理边权非负的问题，在问题无解的情况下效率不如 BFS

核心就是给出一个估价函数，得知未来的总长度时多少，每次选择估计的总长度最小的长度出队  

---

证明: 

```cpp
d[state] + g[state] 
d[state] + f[state] 
保证了 (f[state] 为到终点的估计距离，g[state] 是到终点的真实距离)
f[state] <= g[state] 规定估计距离小于等于实际距离
```

为什么当终点出队的时候，他的最小值就一定是正确的？ 

假设终点第一次出队的时候，他不是最小值，就意味着这个 `dist > dist[最优解]`  
由于使用的估价值小于等于真实值，假设最优解为 u `d(u)+f(u) <= d(u)+g(u)`, `d(u)+g(u) == dist[最优解]`

所以 `dist > dist[最优解] >= d(u)+f(u)`，也就是说队列中存在一个比队头更小的元素，和最小值出队矛盾  
所以当终点出队的时候，说他不是最优解就是不对的，所以当终点出队的时候是最优解

第一次出队就取到最小值的这个特性只对终点成立，对其他所有点都不成立  
在 astar 算法中，并不是每一个点只会被遍历一次，可能存在一个拨乱反正的过程

---

- 对于 bfs 而言，每个状态只会入队一次，所以可以在入队的时候进行判重
- 对于 dijkstra 而言，只要出队就是正确的，所以可以在出队的时候进行判重
- 对于 a*，出队的时候都不能判重，出队一次更新一次，不需要进行判重

估计距离：   
使用一些比较成熟的估价方法，拿来直接用，如果是比较新的问题，猜一个估价函数，只要保证大于等于 0 同时小于真实值就可以了


---

举例：

八数码
八数码有解的充要条件，序列中的逆序对的数量是偶数

如何设计估价函数： 
- 每一次的移动，最多只会把某一个数字向目标数字移动一位
- 所以可以取当前状态和最终状态中的，每一个数字的曼哈顿距离之和

```cpp

```

第 K 短路

弹第一次就是第 1 小的，弹第 2 次就是第二小的，弹第 k 次就是第 k 小的

```cpp

```

