/*
 * @lc app=leetcode.cn id=779 lang=golang
 *
 * [779] 第K个语法符号
 */
package leetcode

/* --- 2022-08-02-10-34 --- */
// https://github.com/fengwei2002/Algorithm

// @lc code=start
func kthGrammar(n int, k int) int {
	lowbit := func(n int) int {
		return n & (-n)
	}
	count := 0
	for k > 0 {
		k -= lowbit(k)
		count++
	}

	if count&1 == 1 {
		return 1
	}
	return 0
}

// @lc code=end

/*
0 -> 01
1 -> 10

找规律:
	可以手动列出来几项观察性质

0
01
0110
0110 1001

规律:
左边一半和上一行完全一样，右边一般是左边一半取反

第一行的长度是 1
第二行的长度是 2
第三行的长度是 4

所以第 n 行的长度就是 2^{n - 1}
	然后看 k 是属于前一段，还是属于后一段
	f(n, k) = f(n - 1, k)      // k 在前一段的话
	f(n, k) = f(n - 1, k - (2^{n-2}) ) ^ 1
		// k 在后一段的话 把这个 k 变为前一段的数字，然后把 0 变为 1 把 1 变为 0


分类讨论：

如果 k 在前一半的话，前半段的总数是 2^{n-2}
	那么k想要在前半段，说明 k 的第 n - 2 的位置就是0
意味着 k 的二进制表示的 n-2 位应该是 0

如果在后一段的话，说明 k 的第 n - 2 的位置是 1

综合考虑，如果在后一段，k的 2^{n-2} 的位置是 1，那么就把这个 1 减去
	k - 2^{n-2}, 然后递归下去执行
	如果是 0 的话，就直接递归

也就是是 1 的话，把 1 减去，并取反
     是 0 的话，不变
所以 k 的值就是二进制表示中 1 的个数，每存在一位 1 就会取反一次
只要有奇数个1就是1，偶数个1就是0
*/
