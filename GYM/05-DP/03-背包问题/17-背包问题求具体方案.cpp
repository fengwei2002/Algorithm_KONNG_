// URL: https://www.acwing.com/problem/content/12/
// NAME: 背包问题求具体方案, AcWing
// LIMIT: 64 MB, 1000 ms
// DATE: 2022-08-03 23:36:17

#include <bits/stdc++.h>

using namespace std;

#ifdef github_fengwei2002
#include "algo/dbg.h"
#else
#define dbg(...) 42
#endif
/*-----------------------*/

const int N = 1010; 

int n, m;
int v[N], w[N];  
int f[N][N]; 

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> m; 
    
    for (int i = 1; i <= n; i++) {
    	cin >> v[i] >> w[i]; 
	}
	
	// f[1][m] 是最大价值 
	// f[i][j] 定义为从第 i 个元素到最后一个元素总容量为 j 的最优解 
	for (int i = n; i >= 1; i--) { // 由于每一次需要后面的状态需要被事先计算过，所以 i 是从大到小循环 
		for (int j = 0; j <= m; j++) {
			f[i][j] = f[i + 1][j]; 
			if (j >= v[i]) {
				f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]); 
			}
		}
	}
	dbg(f[1][m]); 
	
	int cur_v = m; 
	for (int i = 1; i <= n; i++) {
		// 如果是最后一个元素，特判一下，防止越界 
		if (i == n && cur_v >= v[i]) {
			cout << i << ' '; 
			break; 
		} 
		
		// 可用容量为 0 的时候，可以退出了
		if (cur_v <= 0) {
			break; 
		} 
		
		// 如果下一个状态是从这个状态转移过去的（选择这个物品) 就把这个物品加到答案序列中 
		if (cur_v - v[i] >= 0 && f[i][cur_v] == f[i+1][cur_v - v[i]] + w[i]) {
			cout << i << ' '; 
			cur_v = cur_v - v[i]; 
		}
	}

    return 0;
}


/*

以 01 背包为例，演示如何在背包问题中，求出具体的方案
f[n][m] 其实是判断出每个物品是否被选择
f[i,j] = max(f[i-1,j], f[i-1][j-v[i]]+w[i]) 


拓扑图代表每个状态的具体表示

每一个状态转移在这个 图中，就是一个有向边
求到达最终状态的具体方案，就等价于，求到达最终节点的最短路的路径



输出字典序最小的方案:
	为了方便出题人，去除 special judge 的过程

大多数情况下可以使用贪心来解决字典序最小
	对于1号节点: 
		只能选: 选
		只能不选: 不选
		可以选可以不选: 选 (维护字典序最小)
	判断完 1 号节点之后，就从 2 号节点开始继续判读



所以可以更新一下状态的定义，为了适应贪心解法从前往后推的过程（默认的01背包是从后往前的过程）
f[i][j] 定义为从第 i 个元素到最后一个元素总容量为 j 的最优解 
接下来考虑状态转移: 
	f[i][j] = max(f[i+1][j], f[i+1][j-v[i]]+w[i]); 
	两种情况，第一种是不选第i个物品，最优解等同于从第i+1个物品到最后一个元素中总容量为 j 的最优解
	第二种是，选了第 i 个物品，那么最优解等于当前物品的价值加上 w[i] 加上从第 i+1 个物品到最后一个元素
		总容量是 j - v[i] 的最优解
		
	这时，如何得到最小字典序就对应了 dp 的推理顺序 
	
	如果 f[1][m] = f[2][m-v[1]]+w[1] 说明选取了第 1 个物品可以得到最优解
	如果 f[1][m] = f[2][m] 说明不选取第一个物品才能得到最优解 
	如果 f[1][m] = f[2][m] = f[2][m-v[1]]+w[1] 说明选或者不选，都可以得到最优解，为了维护字典序最小，选这个物品 
*/