{
   "P": {
       "prefix": "P",
       "body": [
           " $0"
       ],
       "description": "空白 "
   },
   "classdsu": {
       "prefix": "classdsu",
       "body": [
           "class DSU { // https://github.com/funcdfs",
           "   private:",
           "   vector<int> f, siz;  // father and size",
           "   public:",
           "   DSU() {}  // DSU dsu(N);",
           "   DSU(int n) { init(n); }",
           "   void init(int n) {",
           "      f.resize(n);",
           "      iota(f.begin(), f.end(), 0);",
           "      siz.assign(n, 1);",
           "   }",
           "   int find(int x) {  // dsu.find(i) == i",
           "      while (x != f[x]) {",
           "         x = f[x] = f[f[x]];",
           "      }",
           "      return x;",
           "   }",
           "   bool same(int x, int y) { return find(x) == find(y); }",
           "   bool merge(int x, int y) {  // dsu.merge(A, B);",
           "      x = find(x);",
           "      y = find(y);",
           "      if (x == y) {",
           "         return false;",
           "      }",
           "      siz[x] += siz[y];",
           "      f[y] = x;",
           "      return true;",
           "   }",
           "   int size(int x) { return siz[find(x)]; }  // s = dsu.size(i);",
           "};",
           ""
       ],
       "description": "数据结构 并查集"
   },
   "pairhash": {
       "prefix": "pairhash",
       "body": [
           "struct pair_hash {",
           "   template <class T1, class T2>",
           "      std::size_t operator () (const std::pair<T1,T2> &p) const {",
           "      auto h1 = std::hash<T1>{}(p.first);",
           "      auto h2 = std::hash<T2>{}(p.second);",
           "      return h1 ^ h2;",
           "   }",
           "};",
           "unordered_map<pair<int, int>, int, pair_hash> $1;$0"
       ],
       "description": "数据结构 unordered_map<pair<int,int>, int>"
   },
   "minPQ 弹出最小值": {
       "prefix": "minPQ",
       "body": [
           "function<bool(int&, int&)> minPQCmp = [](int& i1, int& i2) {",
           "   return i1 > i2;",
           "}; // 弹出元素是最小值",
           "priority_queue<int, vector<int>, function<bool(int&, int&)>> minPQ(minPQCmp);"
       ],
       "description": "数据结构 minPQ 弹出元素是最小值的堆"
   },
   "maxPQ 弹出最大值": {
       "prefix": "maxPQ",
       "body": [
           "function<bool(int&, int&)> maxPQCmp = [](int& i1, int& i2) {",
           "   return i1 < i2;",
           "}; // 弹出元素是最大值",
           "priority_queue<int, vector<int>, function<bool(int&, int&)>> maxPQ(maxPQCmp);"
       ],
       "description": "数据结构 maxPQ 弹出元素是最大值的堆"
   },
   "unique(a.begin(), a.end())": {
       "prefix": "unique",
       "body": [
           "sort($1.begin(), $1.end()), $1.erase(unique($1.begin(), $1.end()), $1.end());$0"
       ],
       "description": "数组 去重"
   },
   "reverse(a.begin(), a.end())": {
       "prefix": "reverse",
       "body": [
           "reverse($1.begin(), $1.end());$0"
       ],
       "description": "数组 翻转"
   },
   "sort(a.begin(), a.end(), [function])": {
       "prefix": "sortfunc",
       "body": [
           "sort($1.begin(), $1.end(), [](const auto& x1, const auto& x2) {",
           "   return $2",
           "});\n$0"
       ],
       "description": "数组 排序"
   },
   "count_if(vector, x)": {
       "prefix": "countif",
       "body": [
           "count_if($1.begin(), $1.end(), [=](const auto& xx){",
           "   return $2;",
           "});\n$0"
       ],
       "description": "数组 count_if 查询"
   },
   "for_each(vector, x)": {
       "prefix": "for_each",
       "body": [
           "for_each($1.begin(), $1.end(), [=](auto& xx){",
           "   return $2;",
           "});\n$0"
       ],
       "description": "for_each x"
   },
   "sort(a)": {
       "prefix": "sort",
       "body": [
           "sort($1.begin(), $1.end());$0"
       ],
       "description": "数组 排序"
   },
   "iota(a.begin(), a.end())": {
       "prefix": "iota",
       "body": [
           "iota($1.begin(), $1.end(), $2);$0"
       ],
       "description": "数组 iota"
   },
   "fill(a.begin(), a.end())": {
       "prefix": "fill",
       "body": [
           "fill($1.begin(), $1.end(), $2);$0"
       ],
       "description": "数组 iota"
   },
   "a.begin() to a.end()": {
       "prefix": "all",
       "body": [
           "$1.begin(), $1.end()$0"
       ],
       "description": "数组 all 迭代器"
   },
   "lowerbound": {
       "prefix": "lowerbound",
       "body": [
           "lower_bound($1.begin(), $1.end(), $2)$0"
       ],
       "description": "数组 二分查找"
   },
   "upperbound": {
       "prefix": "upperbound",
       "body": [
           "upper_bound($1.begin(), $1.end(), $2)$0"
       ],
       "description": "数组 二分查找"
   },
   "binary_search_example": {
       "prefix": "binary_search_example",
       "body": [
           "/* binary search:",
           "",
           "value a a a b b b c c c",
           "index 0 1 2 3 4 5 6 7 8",
           "bound\t\t l\t  u",
           "",
           "*/",
           ""
       ],
       "description": "二分查找举例"
   },
   "clear(v, n)": {
       "prefix": "clear",
       "body": [
           "$1.clear(), $1.resize($2);$0"
       ],
       "description": "数组 清空 clear"
   },
   "accumulate(a.begin(), a.end(), 0)": {
       "prefix": "accumulate",
       "body": [
           "accumulate($1.begin(), $1.end(), int64_t(0));$0"
       ],
       "description": "数组 求和"
   },
   "iii": {
       "prefix": "iii",
       "body": [
           "int64"
       ],
       "description": "变量 int64 简写 iii"
   },
   "min": {
       "prefix": "min",
       "body": [
           "min({$1});$0"
       ],
       "description": "变量 最小值"
   },
   "max": {
       "prefix": "max",
       "body": [
           "max({$1});$0"
       ],
       "description": "变量 最大值"
   },
   "int32max": {
       "prefix": "int32max",
       "body": [
           "numeric_limits<int32>::max()$0"
       ],
       "description": "常量"
   },
   "int32min": {
       "prefix": "int32min",
       "body": [
           "numeric_limits<int32>::min()$0"
       ],
       "description": "常量"
   },
   "int64max": {
       "prefix": "int64max",
       "body": [
           "numeric_limits<int64>::max()$0"
       ],
       "description": "常量"
   },
   "int64min": {
       "prefix": "int64min",
       "body": [
           "numeric_limits<int64>::min()$0"
       ],
       "description": "常量"
   },
   "dxdy4": {
       "prefix": "dxdy4",
       "body": [
           "array<int, 4> dx = {-1, 1, 0, 0};",
           "array<int, 4> dy = {0, 0, -1, 1};\n"
       ],
       "description": "变量  四方向的 dx dy"
   },
   "dxdy8": {
       "prefix": "dxdy8",
       "body": [
           "array<int, 8> dx = {0, 1, 1, 1, 0, -1, -1, -1};",
           "array<int, 8> dy = {1, 1, 0, -1, -1, -1, 0, 1};\n"
       ],
       "description": "变量  八方向的 dx dy"
   },
   "fori": {
       "prefix": "fori",
       "body": [
           "for (int i = $1; i < $2; i++) {",
           "   $0",
           "}"
       ],
       "description": "缩写 循环 i"
   },
   "forj": {
       "prefix": "forj",
       "body": [
           "for (int j = $1; j < $2; j++) {",
           "   $0",
           "}"
       ],
       "description": "缩写 循环 j"
   },
   "fork": {
       "prefix": "fork",
       "body": [
           "for (int k = $1; k < $2; k++) {",
           "   $0",
           "}"
       ],
       "description": "缩写 循环 k"
   },
   "int(a.size())": {
       "prefix": "size",
       "body": [
           "int($1.size())$0 "
       ],
       "description": "缩写 size"
   },
   "*min_element(a.begin(), a.end());": {
       "prefix": "min_ele",
       "body": [
           "*min_element($1.begin(), $1.end());\n$0"
       ],
       "description": "缩写 min_element"
   },
   "*max_element(a.begin(), a.end());": {
       "prefix": "max_ele",
       "body": [
           "*max_element($1.begin(), $1.end());\n$0"
       ],
       "description": "缩写 max_element"
   },
   "": {
       "prefix": "",
       "body": [
           " $0"
       ],
       "description": "空白 "
   },
   "print": {
       "prefix": "print",
       "body": [
           "print(\"$1\\n\", $2); $0"
       ],
       "description": "输出 C++20"
   },
   "printx": {
       "prefix": "printx",
       "body": [
           "print(\"{0} \", $1); $0"
       ],
       "description": "输出 C++20"
   },
   "pln": {
       "prefix": "pln",
       "body": [
           "print(\"{0}\\n\", \"\"); \n$0"
       ],
       "description": "输出 C++20"
   },
   "eprint": {
       "prefix": "eprint",
       "body": [
           "eprint(\"$1\\n\", $2); $0"
       ],
       "description": "输出 C++20"
   },
   "eprintx": {
       "prefix": "eprintx",
       "body": [
           "eprint(\"{0} \", $1); $0"
       ],
       "description": "输出 C++20"
   },
   "eln": {
       "prefix": "eln",
       "body": [
           "eprint(\"{0}\\n\", \"\"); \n$0"
       ],
       "description": "输出 C++20"
   },
   "print kickstart Case": {
       "prefix": "printcase",
       "body": [
           "print(\"Case #{0}: \", _case);$0"
       ],
       "description": "输出 C++20"
   },
   "coutYes": {
       "prefix": "coutYes",
       "body": [
           "cout << \"Yes\\n\";"
       ],
       "description": "输出 Yes 字符串"
   },
   "coutYES": {
       "prefix": "coutYES",
       "body": [
           "cout << \"YES\\n\";"
       ],
       "description": "输出 YES 字符串"
   },
   "coutNo": {
       "prefix": "coutNo",
       "body": [
           "cout << \"No\\n\";"
       ],
       "description": "输出 No 字符串"
   },
   "coutNO": {
       "prefix": "coutNO",
       "body": [
           "cout << \"NO\\n\";"
       ],
       "description": "输出 NO 字符串"
   },
   "dbg": {
       "prefix": "dbg",
       "body": [
           "dbg($1);\n$0"
       ],
       "description": "输出调试 字符串"
   },
   "dbg(\"HI\")": {
       "prefix": "dbghi",
       "body": [
           "dbg(\"HI\");\n"
       ],
       "description": "输出调试 字符串"
   },
   "C(a,b) 从 a 个元素中选出 b 个元素的可能数": {
       "prefix": "Cab",
       "body": [
           "auto C = [](int64_t aa, int64_t bb) -> int64_t {",
           "   int64_t ans = 1;",
           "   for (int64_t i = aa, j = 1; j <= bb; i--, j++) ans = ans * i / j;",
           "   return ans;",
           "};"
       ],
       "description": "数学 C(a,b) 从 a 个元素中选出 b 个元素的可能数"
   },
   "divfunc": {
       "prefix": "divfunc",
       "body": [
           "// 上下取整函数",
           "auto floor_div(int64_t x, int64_t y) -> int64_t {",
           "   assert(y != 0);",
           "   if (y < 0) {",
           "      y = -y;",
           "      x = -x;",
           "   }",
           "   if (x >= 0) return x / y;",
           "   return (x + 1) / y - 1;",
           "}",
           "auto ceil_div(int64_t x, int64_t y) -> int64_t {",
           "   assert(y != 0);",
           "   if (y < 0) {",
           "      y = -y;",
           "      x = -x;",
           "   }",
           "   if (x <= 0) return x / y;",
           "   return (x - 1) / y + 1;",
           "}"
       ],
       "description": "数学 div 上下取整函数"
   },
   "gcd": {
       "prefix": "gcd",
       "body": [
           "template <typename T>",
           "T gcd(T a, T b) {",
           "\ta = abs(a);",
           "\tb = abs(b);",
           "\tif (a < b) {",
           "\t\tswap(a, b);",
           "\t}",
           "\twhile (b) {",
           "\t\tT r = a % b;",
           "\t\ta = b;",
           "\t\tb = r;",
           "\t}",
           "\treturn a;",
           "}"
       ],
       "description": "数学 gcd"
   },
   "isPrime": {
       "prefix": "isPrime",
       "body": [
           "auto isPrime = [&](auto x) -> bool {",
           "   if (x < 2) {",
           "      return false;  // 判断是否大于 1",
           "   }",
           "   for (int i = 2; i * i <= x; i++) {",
           "      // 判断从 2 到 i - 1 是否包含 n 的约数，是的话，返回 false，",
           "      // 否则返回 true",
           "      if (x % i == 0) {",
           "         return false;",
           "      }",
           "   }",
           "   return true;",
           "};"
       ],
       "description": "数学 判断质数"
   },
   "pbds": {
       "prefix": "pbds",
       "body": [
           "#include <ext/pb_ds/assoc_container.hpp>\t// Common file",
           "#include <ext/pb_ds/tree_policy.hpp>\t\t // Including tree_order_statistics_node_update",
           "using namespace __gnu_pbds;",
           "",
           "template <class T>",
           "using TreeSet = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
           "template <class T> ",
           "using TreeMap = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
           "",
           "",
           "/*",
           "If using TreeMap with less_equal:",
           "\tRanking of x:                                                 mt.order_of_key(x) + 1",
           "\tFind the number with rank idx:                                *mt.find_by_order(idx)",
           "\tTo delete only one of multiple identical numbers:             mt.erase(st.upper_bound(x));",
           "\tPredecessor is defined as the largest number less than x:     *--mt.upper_bound(x)",
           "\tSuccessor is defined as the smallest number greater than x:   *mt.lower_bound(x)",
           "*/"
       ],
       "description": "pbds"
   },
   "Modular_DefineCode": {
       "prefix": "Modular_DefineCode",
       "body": [
           "",
           "",
           "#pragma region Modular_DefineCode // clang-format off",
           "template <typename T> T inverse(T a, T m) {",
           "\tT u = 0, v = 1; while (a != 0) { T t = m / a;",
           "\tm -= t * a; swap(a, m); u -= t * v; swap(u, v); }",
           "\tassert(m == 1); return u; }",
           "template <typename T> class Modular { public:",
           "\tusing Type = typename decay<decltype(T::value)>::type;",
           "\tconstexpr Modular() : value() {}",
           "\ttemplate <typename U> Modular(const U& x) { value = normalize(x); }",
           "\ttemplate <typename U> static Type normalize(const U& x) { Type v; ",
           "\t\tif (-mod() <= x && x < mod()) { v = static_cast<Type>(x); }",
           "\t\telse {v = static_cast<Type>(x % mod());} if (v < 0) v += mod(); return v; }",
           "\tconst Type& operator()() const { return value; }",
           "\ttemplate <typename U> explicit operator U() const { return static_cast<U>(value); }",
           "\tconstexpr static Type mod() { return T::value; }",
           "",
           "\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
           "\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
           "\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
           "\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
           "\tModular& operator++() { return *this += 1; }",
           "\tModular& operator--() { return *this -= 1; }",
           "\tModular operator++(int) { Modular result(*this); *this += 1; return result; }",
           "\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }",
           "\tModular operator-() const { return Modular(-value); }",
           "",
           "\ttemplate <typename U = T>",
           "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
           "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value)); return *this; }",
           "\ttemplate <typename U = T>",
           "\ttypename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
           "\t\tlong long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
           "\t\tvalue = normalize(value * rhs.value - q * mod()); return *this; }",
           "\ttemplate <typename U = T>",
           "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
           "\t\tvalue = normalize(value * rhs.value); return *this; }",
           "\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
           "\tfriend const Type& abs(const Modular& x) { return x.value; }",
           "\ttemplate <typename U> friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
           "\ttemplate <typename U> friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
           "\ttemplate <typename V, typename U> friend V& operator>>(V& stream, Modular<U>& number);",
           "",
           " private:",
           "  Type value;",
           "};",
           "",
           "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
           "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
           "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
           "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
           "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
           "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
           "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
           "",
           "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
           "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
           "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
           "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
           "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
           "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
           "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
           "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
           "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
           "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
           "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
           "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
           "",
           "template<typename T, typename U> Modular<T> power(const Modular<T>& a, const U& b) {",
           "\tassert(b >= 0); Modular<T> x = a, res = 1; U p = b;",
           "\twhile (p > 0) { if (p & 1) res *= x; x *= x; p >>= 1; } return res; }",
           "template <typename T> bool IsZero(const Modular<T>& number) {",
           "\treturn number() == 0; }",
           "template <typename T> string to_string(const Modular<T>& number) {",
           "\treturn to_string(number()); }",
           "",
           "// U == std::ostream? but done this way because of fastoutput",
           "template <typename U, typename T> U& operator<<(U& stream, const Modular<T>& number) {",
           "\treturn stream << number(); }",
           "// U == std::istream? but done this way because of fastinput",
           "template <typename U, typename T> U& operator>>(U& stream, Modular<T>& number) {",
           "\ttypename common_type<typename Modular<T>::Type, long long>::type x;",
           "\tstream >> x; number.value = Modular<T>::normalize(x); return stream; }",
           "",
           "// inverse(a, m);\t  power(a, b);\t\tC(n, k);\t\tFact(n); ",
           "",
           "#pragma endregion Modular_DefineCode\t// clang-format on",
           "",
           "",
           "// using ModType = int; /* dynamic mod */",
           "// struct VarMod { static ModType value; };",
           "// ModType VarMod::value;",
           "// ModType& md = VarMod::value;",
           "// using Mint = Modular<VarMod>;",
           "",
           "",
           "constexpr int md = ${0:1000000007;}\t// 1000000007\t998244353\t2147483647\t4294967295\t9223372036854775807",
           "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
           "",
           "// vector<Mint> fact(1, 1);",
           "// vector<Mint> inv_fact(1, 1);",
           "// Mint C(int n, int k) {",
           "// \tif (k < 0 || k > n) {",
           "// \t  return 0;",
           "// \t}",
           "// \twhile ((int) fact.size() < n + 1) {",
           "// \t  fact.push_back(fact.back() * (int) fact.size());",
           "// \t  inv_fact.push_back(1 / fact.back());",
           "// \t}",
           "// \treturn fact[n] * inv_fact[k] * inv_fact[n - k];",
           "// }",
           "",
           "",
           "// vector<Mint> fact(1, 1);",
           "// Mint F(int n) {",
           "//\t while (int(fact.size()) < n + 1) {",
           "//\t\t fact.push_back(fact.back() * (int)fact.size());",
           "//\t }",
           "//\t return fact[n];",
           "// }",
           "",
           "",
           ""
       ],
       "description": "Modular_DefineCode"
   },
   "factorizer_DefineCode": {
       "prefix": "factorizer_DefineCode",
       "body": [
           "",
           "#pragma region factorizer_DefineCode // clang-format off",
           "",
           "namespace factorizer {\t// 质数因子分解器",
           "\ttemplate <typename T> struct FactorizerVarMod { static T value; };",
           "\ttemplate <typename T> T FactorizerVarMod<T>::value;",
           "",
           "\ttemplate <typename T> ",
           "\tbool IsPrime(T n, const vector<T>& bases) {",
           "\t\tif (n < 2) { return false; } vector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
           "\t\tfor (const T& x:small_primes){if(n%x==0){return n==x;}}if(n<31*31){return true; }",
           "\t\tint s = 0; T d = n - 1; while ((d & 1) == 0) { d >>= 1; s++; }",
           "\t\tFactorizerVarMod<T>::value = n; for (const T& a : bases) { if (a % n == 0) { continue; }",
           "\t\tModular<FactorizerVarMod<T>> cur=a;cur=power(cur,d);if(cur==1){continue;}bool witness = true;",
           "\t\tfor (int r = 0; r < s; r++) { if (cur == n - 1) { witness = false; break; } cur *= cur; }",
           "\t\tif (witness) { return false; } } return true;",
           "\t}",
           "\t// 判断一个数是否为质数的函数 for int64",
           "\tbool IsPrime(int64_t n) { return IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});}",
           "\t// 判断一个数是否为质数的函数 for int32",
           "\tbool IsPrime(int32_t n) { return IsPrime(n, {2, 7, 61}); }",
           "",
           "\t// but if you really need uint64_t version...",
           "\t/*",
           "\tbool IsPrime(uint64_t n) {",
           "\t\tif (n < 2) { return false; }",
           "\t\tvector<uint32_t> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
           "\t\tfor (uint32_t x : small_primes) { if (n == x) { return true; } if (n % x == 0) { return false; } }",
           "\t\tif (n < 31 * 31) { return true; } uint32_t s = __builtin_ctzll(n - 1); uint64_t d = (n - 1) >> s;",
           "\t\tfunction<bool(uint64_t)> witness = [&n, &s, &d](uint64_t a) {",
           "\t\t\tuint64_t cur = 1, p = d; while (p > 0) { if (p & 1) { cur = (__uint128_t) cur * a % n; }",
           "\t\t\ta = (__uint128_t) a * a % n; p >>= 1; } if (cur == 1) { return false; }",
           "\t\t\tfor (uint32_t r = 0; r < s; r++) { if (cur == n - 1) { return false; } cur = (__uint128_t) cur * cur % n;}",
           "\t\t\treturn true;",
           "\t\t}; vector<uint64_t> bases_64bit = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
           "\t\tfor (uint64_t a : bases_64bit) { if (a % n == 0) { return true; } if (witness(a)) { return false;}}",
           "\t\treturn true;",
           "\t}",
           "\t*/",
           "\t// 存储范围内的所有的质数",
           "\tvector<int> primes;\t",
           "\tvector<int> least = {0, 1};  int precalculated = 1;",
           "\t",
           "\t// 使用线性筛法筛选质数",
           "\tvoid RunLinearSieve(int n) {",
           "\t\tn = max(n, 1); least.assign(n + 1, 0); primes.clear();",
           "\t\tfor (int i = 2; i <= n; i++) { if (least[i] == 0) { least[i] = i; primes.push_back(i); }",
           "\t\t\tfor (int x : primes) { if (x > least[i] || i * x > n) { break; } least[i * x] = x; } }",
           "\t\tprecalculated = n;",
           "\t}",
           "\t",
           "\t// 使用慢速筛法筛选质数",
           "\tvoid RunSlowSieve(int n) {",
           "\t\tn = max(n, 1); least.assign(n + 1, 0);",
           "\t\tfor (int i = 2; i * i <= n; i++) { if (least[i] == 0) { for (int j = i * i; j <= n; j += i) {",
           "\t\tif (least[j] == 0) { least[j] = i; } } } } primes.clear(); for (int i = 2; i <= n; i++) {",
           "\t\tif (least[i] == 0) { least[i] = i; primes.push_back(i); } } precalculated = n;",
           "\t}",
           "\t",
           "\t// 筛选范围内的所有质数",
           "\tvoid RunSieve(int n) {",
           "\t\tRunLinearSieve(n);",
           "\t\t// RunSlowSieve(n);",
           "\t}",
           "\tint PrimesSize() { return int(factorizer::primes.size()); }",
           "\t",
           "\t// 合并两个阶乘分解结果 到一个阶乘列表",
           "\ttemplate <typename T> ",
           "\tvector<pair<T, int>> MergeFactors(const vector<pair<T, int>>& a, const vector<pair<T, int>>& b) {",
           "\t\tvector<pair<T, int>> c; int i = 0; int j = 0;",
           "\t\twhile (i < (int)a.size() || j < (int)b.size()) { if (i < (int)a.size() && j < (int)b.size() ",
           "\t\t&&a[i].first==b[j].first){c.emplace_back(a[i].first,a[i].second+b[j].second);++i;++j; continue; }",
           "\t\tif (j == (int)b.size() || (i < (int)a.size() && a[i].first < b[j].first)) { c.push_back(a[i++]); } ",
           "\t\telse { c.push_back(b[j++]); }} return c;",
           "\t}",
           "",
           "\t// 使用 Pollard's rho 算法进行质因数分解.",
           "\ttemplate <typename T>",
           "\tvector<pair<T, int>> RhoC(const T& n, const T& c) { if (n <= 1) { return {}; }",
           "\t\tif ((n & 1) == 0) { return MergeFactors( { {2, 1} }, RhoC(n / 2, c)); }",
           "\t\tif (IsPrime(n)) {return{{n,1}};}FactorizerVarMod<T>::value = n; Modular<FactorizerVarMod<T>> x = 2; ",
           "\t\tModular<FactorizerVarMod<T>> saved = 2; T power = 1; T lam = 1; while (true) { x = x * x + c;",
           "\t\t\tT g=__gcd((x-saved)(),n);if(g!=1){return MergeFactors(RhoC(g,c+1),RhoC(n/g,c+1));}",
           "\t\t\tif (power == lam) { saved = x; power <<= 1; lam = 0; } lam++;",
           "\t\t} return {};",
           "\t}",
           "",
           "\t// 给定一个整数 N ，试快速找到它的一个因数。使用 Pollard's rho 算法进行质因数分解.",
           "\ttemplate <typename T>",
           "\tvector<pair<T, int>> Rho(const T& n) { return RhoC(n, static_cast<T>(1)); }",
           "",
           "\t// 将一个整数分解成分项阶乘的和 vector<pair<int, int>>",
           "\ttemplate <typename T>",
           "\tvector<pair<T, int>> Factorize(T x) {",
           "\t\tif (x <= 1) { return {}; } if (x <= precalculated) { vector<pair<T, int>> ret;",
           "\t\twhile (x > 1) { if (!ret.empty() && ret.back().first == least[x]) { ret.back().second++;",
           "\t\t} else { ret.emplace_back(least[x], 1); } x /= least[x]; }return ret; }",
           "\t\tif (x <= static_cast<int64_t>(precalculated) * precalculated) {",
           "\t\tvector<pair<T, int>> ret; if (!IsPrime(x)){for(T i:primes){T t=x/i;if(i>t){break;}",
           "\t\tif (x == t * i) { int cnt = 0; while (x % i == 0) { x /= i; cnt++; } ret.emplace_back(i, cnt);",
           "\t\tif(IsPrime(x)){break;}}}}if(x>1){ret.emplace_back(x,1);}return ret;}return Rho(x);",
           "\t}",
           "",
           "\t// 根据一个分项阶乘的列表 构建出这个数字的所有质因数 vector",
           "\ttemplate <typename T>",
           "\tvector<T> BuildDivisorsFromFactors(const vector<pair<T, int>>& factors) {",
           "\t\tvector<T> divisors = {1}; for (auto& p : factors) { int sz = (int)divisors.size();",
           "\t\tfor (int i = 0; i < sz; i++) { T cur = divisors[i]; for (int j = 0; j < p.second; j++) {",
           "\t\tcur*=p.first;divisors.push_back(cur);}}}sort(divisors.begin(),divisors.end());return divisors;",
           "\t}",
           "}\t// namespace factorizer",
           "",
           "#pragma endregion factorizer_DefineCode\t// clang-format on",
           ""
       ],
       "description": "数学 质因子分解器 factorizer_DefineCode"
   },
   "lucas": {
       "prefix": "lucas",
       "body": [
           "int factMod(int a, int k, int p) {",
           "\tint res = 1 % p;",
           "\twhile (k) {",
           "\t\tif (k & 1) {",
           "\t\t\tres = (int64)res * a % p;",
           "\t\t}",
           "\t\ta = (int64)a * a % p;",
           "\t\tk >>= 1;",
           "\t}",
           "\treturn res;",
           "}",
           "",
           "int CabMod(int a, int b, int p) {",
           "\tif (b > a) {",
           "\t\treturn 0;",
           "\t}",
           "\tif (b > a - b) {",
           "\t\tb = a - b;",
           "\t}",
           "\tint64 x = 1, y = 1;",
           "\tfor (int i = 0; i < b; i++) {",
           "\t\tx = x * (a - i) % p;",
           "\t\ty = y * (i + 1) % p;",
           "\t}",
           "\treturn x * factMod(y, p - 2, p) % p;",
           "}",
           "",
           "int lucas(int64 a, int64 b, int p) {",
           "\tif (a < p && b < p) {",
           "\t\treturn CabMod(a, b, p);",
           "\t}",
           "\treturn (int64)CabMod(a % p, b % p, p) * lucas(a / p, b / p, p) % p;",
           "}\t// lucas(a, b, p)  ==  C(a, b) mod p"
       ],
       "description": "数学 lucas"
   },
   "StringHash": {
       "prefix": "StringHash",
       "body": [
           "#pragma region StringHash_DefineCode // !! don't forget\t\t  initStringHash();",
           "",
           "const int mod1 = 1e9 + 7, base1 = 27;",
           "const int mod2 = 1e9 + 9, base2 = 31;\t//\t31\t131\t 13131",
           "const int maxn = 1e6 + 10;",
           "int64 val1[maxn], val2[maxn];",
           "",
           "void initStringHash() {",
           "\tval1[0] = val2[0] = 1;",
           "\tfor (int i = 1; i < maxn; i++) {",
           "\t\tval1[i] = val1[i - 1] * base1 % mod1;",
           "\t\tval2[i] = val2[i - 1] * base2 % mod2;",
           "\t}",
           "}",
           "",
           "struct StringHash {",
           "\t\tstring s;",
           "\t\tvector<int64> hash1, hash2;",
           "",
           "\t\tStringHash(string _s) : s(_s), hash1 {0}, hash2 {0} {",
           "\t\t\tfor (auto i : s) {",
           "\t\t\t\thash1.push_back((hash1.back() * base1 % mod1 + i) % mod1);",
           "\t\t\t\thash2.push_back((hash2.back() * base2 % mod2 + i) % mod2);",
           "\t\t\t}",
           "\t\t}",
           "",
           "\t\tvoid add(string news) {",
           "\t\t\ts += news;",
           "\t\t\tfor (auto i : news) {",
           "\t\t\t\thash1.push_back((hash1.back() * base1 % mod1 + i) % mod1);",
           "\t\t\t\thash2.push_back((hash2.back() * base2 % mod2 + i) % mod2);",
           "\t\t\t}",
           "\t\t}",
           "",
           "\t\tpair<int64, int64> get() {",
           "\t\t\treturn {hash1.back(), hash2.back()};",
           "\t\t}",
           "",
           "\t\tpair<int64, int64> substrRange(int l, int r) {",
           "\t\t\tint64 a = ((hash1[r + 1] - hash1[l] * val1[r - l + 1] % mod1) % mod1 + mod1) % mod1;",
           "\t\t\tint64 b = ((hash2[r + 1] - hash2[l] * val2[r - l + 1] % mod2) % mod2 + mod2) % mod2;",
           "\t\t\treturn {a, b};",
           "\t\t}",
           "",
           "\t\tpair<int64, int64> substr(int st, int len) {",
           "\t\t\tint l = st, r = st + len - 1;",
           "\t\t\tint64 a = ((hash1[r + 1] - hash1[l] * val1[r - l + 1] % mod1) % mod1 + mod1) % mod1;",
           "\t\t\tint64 b = ((hash2[r + 1] - hash2[l] * val2[r - l + 1] % mod2) % mod2 + mod2) % mod2;",
           "\t\t\treturn {a, b};",
           "\t\t}",
           "};",
           "",
           "#pragma endregion StringHash_DefineCode\t// !! don't forget\t\t  initStringHash();"
       ],
       "description": "字符串 StringHash"
   },
   "string_algo_Z_func": {
       "prefix": "string_algo_Z_func",
       "body": [
           "// z[x] 计算 s[x:] 和 s[0:] 的最长公共前缀的长度，z[0] = 0。（例如 abacaba -> 0010301）。 O(n) 复杂度",
           "template <typename T>",
           "vector<int> z_func(int n, const T &s) {",
           "\tvector<int> z(n, n);",
           "\tint l = 0, r = 0;",
           "\tfor (int i = 1; i < n; i++) {",
           "\t\tz[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
           "\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
           "\t\t\tz[i]++;",
           "\t\t}",
           "\t\tif (i + z[i] - 1 > r) {",
           "\t\t\tl = i;",
           "\t\t\tr = i + z[i] - 1;",
           "\t\t}",
           "\t}",
           "\treturn z;",
           "}",
           "",
           "template <typename T>",
           "vector<int> z_func(const T &s) {",
           "\treturn z_function(int(s.size()), s);",
           "}"
       ],
       "description": "字符串 string_algo_Z_func"
   },
   "construct_prefix": {
       "prefix": "string_algo_construct_prefix",
       "body": [
           "// max len of ( s[0:k-1] == s[i-(k-1):i] ) time: O(N) eg: \"aabaaab\" 0 1 0 1 2 2 3",
           "vector<int> construct_prefix(string s) {",
           "\tconst int n = int(s.size());",
           "\tvector<int> pi(n);",
           "\tfor (int i = 1; i < n; i++) {",
           "\t\tint j = pi[i - 1];",
           "\t\twhile (j > 0 && s[i] != s[j]) {",
           "\t\t\tj = pi[j - 1];",
           "\t\t}",
           "\t\tif (s[i] == s[j]) {",
           "\t\t\tj++;",
           "\t\t}",
           "\t\tpi[i] = j;",
           "\t}",
           "\treturn pi;",
           "}"
       ],
       "description": "字符串 construct_prefix"
   },
   "string_algo_kmp": {
       "prefix": "string_algo_kmp",
       "body": [
           "// max len of ( s[0:k-1] == s[i-(k-1):i] ) time: O(N) eg: \"aabaaab\" 0 1 0 1 2 2 3 ",
           "vector<int> construct_prefix(string s) {",
           "\tconst int n = int(s.size());",
           "\tvector<int> pi(n);",
           "\tfor (int i = 1; i < n; i++) {",
           "\t\tint j = pi[i - 1];",
           "\t\twhile (j > 0 && s[i] != s[j]) {",
           "\t\t\tj = pi[j - 1];",
           "\t\t}",
           "\t\tif (s[i] == s[j]) {",
           "\t\t\tj++;",
           "\t\t}",
           "\t\tpi[i] = j;",
           "\t}",
           "\treturn pi;",
           "}",
           "",
           "// KMP: 求出模式串 pattern 在字符串 text 中所有出现的位置的起始下标 time: O(N+M) space: O(N)",
           "vector<int> find_occurrences(string text, string pattern) {",
           "\tstring cur = pattern + '#' + text;",
           "\tint sz1 = int(text.size()), sz2 = int(pattern.size());",
           "\tvector<int> v;",
           "\tvector<int> lps = construct_prefix(cur);",
           "\tfor (int i = sz2 + 1; i <= sz1 + sz2; i++) {",
           "\t\tif (lps[i] == sz2) {",
           "\t\t\tv.push_back(i - 2 * sz2);",
           "\t\t}",
           "\t}",
           "\treturn v;",
           "}",
           ""
       ],
       "description": "string_algo_kmp"
   },
   "globalVar": {
       "prefix": "globalVar",
       "body": [
           "// Define global variables:",
           "const int32 MAX_N = 1e7 + 10;",
           "const int32 INF_INT_32 = 0x3f3f3f3f;",
           "const int64 INF_INT_64 = 0x3f3f3f3f3f3f3f3fll;",
           "const float64 EPS = 1e-12; ",
           "const float64 PI = 3.141592653589793",
           "",
           "// Initialize global variables function, all initialization code for global variables:",
           "int initGlobalVar = []() {",
           "\t",
           "\t$0",
           "",
           "\treturn 0;",
           "}();"
       ],
       "description": "globalVar"
   },
   "check": {
       "prefix": "check",
       "body": [
           "auto check = [&]() -> bool {",
           "   $0",
           "};"
       ],
       "description": "函数 判断正误 输出 YES NO"
   },
   "checkYESNO": {
       "prefix": "check_YES_NO",
       "body": [
           "if (check() == true) {",
           "\tprintln(\"YES\");",
           "} else {",
           "\tprintln(\"NO\");",
           "}"
       ]
   },
   "func": {
       "prefix": "func",
       "body": [
           "auto $1 = [=$2]($3) -> $4 { // =, &a, &b",
           "   $0",
           "};"
       ],
       "description": "函数 func"
   },
   "funcdfs": {
       "prefix": "funcdfs",
       "body": [
           "function<void($3)>dfs = [&](int $2) -> void {",
           "   $1",
           "};$0"
       ],
       "description": "函数 funcdfs"
   },
   "author_time_comment": {
       "prefix": "author_time_comment",
       "body": [
           "/**",
           " * author: https://github.com/funcdfs",
           " * created: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
           "**/",
           ""
       ],
       "description": " github 链接 + 当前时间"
   },
   "using_int128": {
       "prefix": "using_int128",
       "body": [
           "using int128 =  __int128;",
           "istream &operator>>(istream &cin, int128 &x) { x = 0; static string s; cin >> s; for (char &c : s) { x = x * 10 + (c - '0'); } return cin; }",
           "ostream &operator<<(ostream &cout, int128 x) { static char s[60]; int tp = 1; s[0] = '0' + char(x % 10); while(x /= 10) { s[tp++] = '0' + char(x % 10); } while(tp--) {cout << s[tp]; } return cout; }",
           ""
       ],
       "description": "using_int128"
   },
   "__if_format": {
       "prefix": "__if_format",
       "body": [
           "#define print(...)   std::cout << format(__VA_ARGS__)\t\t\t  /* C++23 std::print()\t-> the format string is printed to the standard output */ ",
           "#define println(...) std::cout << format(\"{0}\\n\", __VA_ARGS__); /* C++23 std::println() -> to print a single value and append a newline */",
           ""
       ],
       "description": "unlock format"
   },
   "cp": {
       "prefix": "cp",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "#include <bits/stdc++.h> ",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
           "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n'\t /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
           "#define print(...)\tstd::cout << __VA_ARGS__ \t\t\t  /* C++23 std::print()\t-> the format string is printed to the standard output */ ",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n' /* C++23 std::println() -> to print a single value and append a newline */",
           "struct _init_end { _init_end() { std::cout << fixed << setprecision(\t\t15\t\t/* float output precision */);  { cin.tie(nullptr); ios::sync_with_stdio(false); }}} __author_github_funcdfs; ",
           "",
           "#ifdef LOCAL /* For local debugging purposes */ ",
           "#include \"algo/dbg.h\"",
           "#else",
           "#define dbg(...)      ;",
           "#define eprint(...)   ;",
           "#define eprintln(...) ;",
           "#endif",
           "",
           "auto solve() -> void; /* main --> */ int32 main() { solve(); return 0; }",
           "#pragma endregion github_funcdfs\t// clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "",
           "auto solve() -> void {",
           "\t",
           "\t",
           "\t",
           "\treturn;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "cp"
   },
   "tt": {
       "prefix": "tt",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "#include <bits/stdc++.h> ",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
           "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n'\t /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
           "#define print(...)   std::cout << __VA_ARGS__ \t\t\t  /* C++23 std::print()\t-> the format string is printed to the standard output */ ",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n' /* C++23 std::println() -> to print a single value and append a newline */",
           "struct _init_end { _init_end() { cout << fixed << setprecision(\t\t15\t\t/* float output precision */);  { cin.tie(nullptr); ios::sync_with_stdio(false); }}} __author_github_funcdfs; ",
           "",
           "#ifdef LOCAL /* For local debugging purposes */ ",
           "#include \"algo/dbg.h\"",
           "#else",
           "#define dbg(...)\t\t;",
           "#define eprint(...)\t;",
           "#define eprintln(...) ;",
           "#endif",
           "",
           "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
           "#pragma endregion github_funcdfs\t// clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "",
           "auto solve(int _case) -> void {",
           "\tdbg(_case);",
           "\t",
           "\t",
           "\t",
           "\treturn;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "tt"
   },
   "ttna": {
       "prefix": "ttna",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "#include <bits/stdc++.h> ",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double; ",
           "/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }",
           "template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n'\t /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */ ",
           "#define print(...)   std::cout << __VA_ARGS__ \t\t\t  /* C++23 std::print()\t-> the format string is printed to the standard output */ ",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n' /* C++23 std::println() -> to print a single value and append a newline */",
           "struct _init_end { _init_end() { cout << fixed << setprecision(\t\t15\t\t/* float output precision */);  { cin.tie(nullptr); ios::sync_with_stdio(false); }}} __author_github_funcdfs; ",
           "",
           "#ifdef LOCAL /* For local debugging purposes */ ",
           "#include \"algo/dbg.h\"",
           "#else",
           "#define dbg(...)\t\t;",
           "#define eprint(...)\t;",
           "#define eprintln(...) ;",
           "#endif",
           "",
           "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
           "#pragma endregion github_funcdfs\t// clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "",
           "auto solve(int _case) -> void {",
           "\tdbg(_case);",
           "",
           "\tint n = 0;",
           "\tcin >> n;",
           "\tvector<int> a(n, 0);",
           "\tcin >> a;",
           "\t",
           "\t",
           "\t",
           "\treturn;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "ttna"
   },
   "lc_all": {
       "prefix": "lc_all",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "",
           "#include <algorithm>",
           "#include <array>",
           "#include <bit>",
           "#include <bitset>",
           "#include <cassert>",
           "#include <chrono>",
           "#include <climits>",
           "#include <cmath>",
           "#include <complex>",
           "#include <cstdlib>",
           "#include <cstring>",
           "#include <ctime>",
           "#include <deque>",
           "#include <functional>",
           "#include <iomanip>",
           "#include <iostream>",
           "#include <list>",
           "#include <map>",
           "#include <numeric>",
           "#include <queue>",
           "#include <random>",
           "#include <ranges>",
           "#include <set>",
           "#include <span>",
           "#include <stack>",
           "#include <string>",
           "#include <tuple>",
           "#include <unordered_map>",
           "#include <unordered_set>",
           "#include <valarray>",
           "#include <vector>",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double;/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n' /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */",
           "#define print(...) std::cout << /*format*/ __VA_ARGS__",
           "/* delete this until clangd support C++23 std::print() -> the format string is printed to the standard output */",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n'",
           "/* delete this until clangd support std::println() -> to print a single value and append a newline */",
           "",
           "#ifdef LOCAL\t\t\t\t\t\t\t\t/* For local debugging purposes */",
           "template <typename A, typename B>std::string to_string(std::pair<A, B> p);template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p);template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p);std::string to_string(const std::string &s) {return '\"' + s + '\"';}std::string to_string(const char *s) {return to_string((std::string)s);}std::string to_string(bool b) {return (b ? \"true\" : \"false\");}std::string to_string(std::vector<bool> v) {bool first = true;std::string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}template <size_t N>std::string to_string(std::bitset<N> v) {std::string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}template <typename A>std::string to_string(A v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}std::string to_string(std::vector<char> &v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += std::string(1, x);}res += \"}\";return res;}template <typename A, typename B>std::string to_string(std::pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +to_string(get<3>(p)) + \")\";}void debug_out() {std::cerr << \"\\n\";}template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {std::cerr << \" \" << to_string(H);debug_out(T...);}",
           "#\tdefine endl\t\t\t '\\n'",
           "#\tdefine eprint(...)\t cerr << (__VA_ARGS__)",
           "#\tdefine eprintln(...) cerr << __VA_ARGS << '\\n'",
           "#\tdefine dbg(...)\t\t std::cerr << (#__VA_ARGS__ == \"_case\" ? \"--- \" : std::to_string(__LINE__))\t\t\t\t\t  << (#__VA_ARGS__ == \"_case\" ? \"✨\" : \"🎉 [\")\t\t\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨\" : #__VA_ARGS__)\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨ --- \" : \"]:\"),\t\t\t\t\t\t\t\t  debug_out(__VA_ARGS__)",
           "#else",
           "#\tdefine dbg(...)\t\t;",
           "#\tdefine eprint(...)\t;",
           "#\tdefine eprintln(...) ;",
           "#endif",
           "",
           "#pragma endregion github_funcdfs   // clang-format on",
           "",
           "/* -------------------- class start -------------------- */",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "$0",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "/* -------------------- class end --------------------  */",
           "",
           "",
           "#ifdef LOCAL",
           "int main() {",
           "\tSolution so;",
           "",
           "",
           "",
           "}",
           "#endif"
       ],
       "description": "lc"
   },
   "cp_all": {
       "prefix": "cp_all",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "",
           "#include <algorithm>",
           "#include <array>",
           "#include <bit>",
           "#include <bitset>",
           "#include <cassert>",
           "#include <chrono>",
           "#include <climits>",
           "#include <cmath>",
           "#include <complex>",
           "#include <cstdlib>",
           "#include <cstring>",
           "#include <ctime>",
           "#include <deque>",
           "#include <functional>",
           "#include <iomanip>",
           "#include <iostream>",
           "#include <list>",
           "#include <map>",
           "#include <numeric>",
           "#include <queue>",
           "#include <random>",
           "#include <ranges>",
           "#include <set>",
           "#include <span>",
           "#include <stack>",
           "#include <string>",
           "#include <tuple>",
           "#include <unordered_map>",
           "#include <unordered_set>",
           "#include <valarray>",
           "#include <vector>",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double;/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n' /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */",
           "#define print(...) std::cout << /*format*/ __VA_ARGS__",
           "/* delete this until clangd support C++23 std::print() -> the format string is printed to the standard output */",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n'",
           "/* delete this until clangd support std::println() -> to print a single value and append a newline */",
           "",
           "#ifdef LOCAL\t\t\t\t\t\t\t\t/* For local debugging purposes */",
           "template <typename A, typename B>std::string to_string(std::pair<A, B> p);template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p);template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p);std::string to_string(const std::string &s) {return '\"' + s + '\"';}std::string to_string(const char *s) {return to_string((std::string)s);}std::string to_string(bool b) {return (b ? \"true\" : \"false\");}std::string to_string(std::vector<bool> v) {bool first = true;std::string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}template <size_t N>std::string to_string(std::bitset<N> v) {std::string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}template <typename A>std::string to_string(A v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}std::string to_string(std::vector<char> &v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += std::string(1, x);}res += \"}\";return res;}template <typename A, typename B>std::string to_string(std::pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +to_string(get<3>(p)) + \")\";}void debug_out() {std::cerr << \"\\n\";}template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {std::cerr << \" \" << to_string(H);debug_out(T...);}",
           "#\tdefine endl\t\t\t '\\n'",
           "#\tdefine eprint(...)\t cerr << (__VA_ARGS__)",
           "#\tdefine eprintln(...) cerr << __VA_ARGS << '\\n'",
           "#\tdefine dbg(...)\t\t std::cerr << (#__VA_ARGS__ == \"_case\" ? \"--- \" : std::to_string(__LINE__))\t\t\t\t\t  << (#__VA_ARGS__ == \"_case\" ? \"✨\" : \"🎉 [\")\t\t\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨\" : #__VA_ARGS__)\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨ --- \" : \"]:\"),\t\t\t\t\t\t\t\t  debug_out(__VA_ARGS__)",
           "#else",
           "#\tdefine dbg(...)\t\t;",
           "#\tdefine eprint(...)\t;",
           "#\tdefine eprintln(...) ;",
           "#endif",
           "",
           "struct _init_end { _init_end() { std::cout << fixed << setprecision(\t\t15\t\t/* float output precision */);  { cin.tie(nullptr); ios::sync_with_stdio(false); }}} __author_github_funcdfs; ",
           "",
           "auto solve() -> void; /* main --> */ int32 main() { solve(); return 0; }",
           "#pragma endregion github_funcdfs\t// clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "auto solve() -> void {",
           "\t ",
           "\t $0",
           "\t ",
           "\t return;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "cp"
   },
   "tt_all": {
       "prefix": "tt_all",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "",
           "#include <algorithm>",
           "#include <array>",
           "#include <bit>",
           "#include <bitset>",
           "#include <cassert>",
           "#include <chrono>",
           "#include <climits>",
           "#include <cmath>",
           "#include <complex>",
           "#include <cstdlib>",
           "#include <cstring>",
           "#include <ctime>",
           "#include <deque>",
           "#include <functional>",
           "#include <iomanip>",
           "#include <iostream>",
           "#include <list>",
           "#include <map>",
           "#include <numeric>",
           "#include <queue>",
           "#include <random>",
           "#include <ranges>",
           "#include <set>",
           "#include <span>",
           "#include <stack>",
           "#include <string>",
           "#include <tuple>",
           "#include <unordered_map>",
           "#include <unordered_set>",
           "#include <valarray>",
           "#include <vector>",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double;/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n' /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */",
           "#define print(...) std::cout << /*format*/ __VA_ARGS__",
           "/* delete this until clangd support C++23 std::print() -> the format string is printed to the standard output */",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n'",
           "/* delete this until clangd support std::println() -> to print a single value and append a newline */",
           "",
           "#ifdef LOCAL\t\t\t\t\t\t\t\t/* For local debugging purposes */",
           "template <typename A, typename B>std::string to_string(std::pair<A, B> p);template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p);template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p);std::string to_string(const std::string &s) {return '\"' + s + '\"';}std::string to_string(const char *s) {return to_string((std::string)s);}std::string to_string(bool b) {return (b ? \"true\" : \"false\");}std::string to_string(std::vector<bool> v) {bool first = true;std::string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}template <size_t N>std::string to_string(std::bitset<N> v) {std::string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}template <typename A>std::string to_string(A v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}std::string to_string(std::vector<char> &v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += std::string(1, x);}res += \"}\";return res;}template <typename A, typename B>std::string to_string(std::pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +to_string(get<3>(p)) + \")\";}void debug_out() {std::cerr << \"\\n\";}template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {std::cerr << \" \" << to_string(H);debug_out(T...);}",
           "#\tdefine endl\t\t\t '\\n'",
           "#\tdefine eprint(...)\t cerr << (__VA_ARGS__)",
           "#\tdefine eprintln(...) cerr << __VA_ARGS << '\\n'",
           "#\tdefine dbg(...)\t\t std::cerr << (#__VA_ARGS__ == \"_case\" ? \"--- \" : std::to_string(__LINE__))\t\t\t\t\t  << (#__VA_ARGS__ == \"_case\" ? \"✨\" : \"🎉 [\")\t\t\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨\" : #__VA_ARGS__)\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨ --- \" : \"]:\"),\t\t\t\t\t\t\t\t  debug_out(__VA_ARGS__)",
           "#else",
           "#\tdefine dbg(...)\t\t;",
           "#\tdefine eprint(...)\t;",
           "#\tdefine eprintln(...) ;",
           "#endif",
           "",
           "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
           "#pragma endregion github_funcdfs   // clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "",
           "auto solve(int _case) -> void {",
           "   dbg(_case);",
           "   ",
           "   $0",
           "   ",
           "   return;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "tt"
   },
   "ttna_all": {
       "prefix": "ttna_all",
       "body": [
           "#pragma region github_funcdfs // clang-format off",
           "",
           "#include <algorithm>",
           "#include <array>",
           "#include <bit>",
           "#include <bitset>",
           "#include <cassert>",
           "#include <chrono>",
           "#include <climits>",
           "#include <cmath>",
           "#include <complex>",
           "#include <cstdlib>",
           "#include <cstring>",
           "#include <ctime>",
           "#include <deque>",
           "#include <functional>",
           "#include <iomanip>",
           "#include <iostream>",
           "#include <list>",
           "#include <map>",
           "#include <numeric>",
           "#include <queue>",
           "#include <random>",
           "#include <ranges>",
           "#include <set>",
           "#include <span>",
           "#include <stack>",
           "#include <string>",
           "#include <tuple>",
           "#include <unordered_map>",
           "#include <unordered_set>",
           "#include <valarray>",
           "#include <vector>",
           "/* using golang types */ using namespace std; using int32 = signed; using uint32 = unsigned; using float32 = double; using int64 = long long; using uint64 = unsigned long long; using float64 = long double;/* vec<(any)> cincout */ template <class T> istream &operator>> (istream &cin,  vector<T> &a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, vector<T>\t\t\t  &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> istream &operator>> (istream &cin,  valarray<T>\t\t\t&a)  { for (auto &x : a) { cin >> x; } return cin; }template <class T> ostream &operator<< (ostream &cout, valarray<T>\t\t\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << ' ' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<vector<T>>\t&a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }template <class T> ostream &operator<< (ostream &cout, vector<valarray<T>> &a)  { int n = int(a.size()); if (!n) { return cout; } cout << a[0]; for (int i = 1; i < n; i++) { cout << '\\n' << a[i]; } return cout; }",
           "#define endl '\\n' /* Use '\\n' instead of std::endl to avoid unnecessary buffer flushes for performance */",
           "#define print(...) std::cout << /*format*/ __VA_ARGS__",
           "/* delete this until clangd support C++23 std::print() -> the format string is printed to the standard output */",
           "#define println(...) std::cout << __VA_ARGS__ << '\\n'",
           "/* delete this until clangd support std::println() -> to print a single value and append a newline */",
           "",
           "#ifdef LOCAL\t\t\t\t\t\t\t\t/* For local debugging purposes */",
           "template <typename A, typename B>std::string to_string(std::pair<A, B> p);template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p);template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p);std::string to_string(const std::string &s) {return '\"' + s + '\"';}std::string to_string(const char *s) {return to_string((std::string)s);}std::string to_string(bool b) {return (b ? \"true\" : \"false\");}std::string to_string(std::vector<bool> v) {bool first = true;std::string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}template <size_t N>std::string to_string(std::bitset<N> v) {std::string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}template <typename A>std::string to_string(A v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}std::string to_string(std::vector<char> &v) {bool first = true;std::string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += std::string(1, x);}res += \"}\";return res;}template <typename A, typename B>std::string to_string(std::pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A, typename B, typename C>std::string to_string(std::tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}template <typename A, typename B, typename C, typename D>std::string to_string(std::tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" +to_string(get<3>(p)) + \")\";}void debug_out() {std::cerr << \"\\n\";}template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {std::cerr << \" \" << to_string(H);debug_out(T...);}",
           "#\tdefine endl\t\t\t '\\n'",
           "#\tdefine eprint(...)\t cerr << (__VA_ARGS__)",
           "#\tdefine eprintln(...) cerr << __VA_ARGS << '\\n'",
           "#\tdefine dbg(...)\t\t std::cerr << (#__VA_ARGS__ == \"_case\" ? \"--- \" : std::to_string(__LINE__))\t\t\t\t\t  << (#__VA_ARGS__ == \"_case\" ? \"✨\" : \"🎉 [\")\t\t\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨\" : #__VA_ARGS__)\t\t\t\t\t\t\t\t\t\t << (#__VA_ARGS__ == \"_case\" ? \"✨ --- \" : \"]:\"),\t\t\t\t\t\t\t\t  debug_out(__VA_ARGS__)",
           "#else",
           "#\tdefine dbg(...)\t\t;",
           "#\tdefine eprint(...)\t;",
           "#\tdefine eprintln(...) ;",
           "#endif",
           "",
           "auto solve(int _case) -> void; int32 main() { int testCaseCnt = 0; cin >> testCaseCnt; for (int _case = 1; _case <= testCaseCnt; _case++) { solve(_case); } return 0; }",
           "#pragma endregion github_funcdfs   // clang-format on",
           "",
           "// ----------------------------- /* Start of useful functions */ -----------------------------",
           "",
           "",
           "auto solve(int _case) -> void {",
           "   dbg(_case);",
           "",
           "   int n = 0;",
           "   cin >> n;",
           "   vector<int> a(n, 0);",
           "   cin >> a;",
           "   ",
           "   $0",
           "   ",
           "   return;",
           "}",
           "",
           "// ----------------------------- /* End of useful functions */ -------------------------------",
           ""
       ],
       "description": "ttna"
   },
   "fastInput": {
       "prefix": "fastInput",
       "body": [
           "",
           "static struct FastInput {",
           "   \tstatic constexpr int BUF_SIZE = 1 << 20;",
           "   \tchar buf[BUF_SIZE];",
           "   \tsize_t chars_read = 0;",
           "   \tsize_t buf_pos = 0;",
           "   \tFILE *in = stdin;",
           "   \tchar cur = 0;",
           "",
           "   \tinline char get_char() {",
           "      \tif (buf_pos >= chars_read) {",
           "         \tchars_read = fread(buf, 1, BUF_SIZE, in);",
           "         \tbuf_pos = 0;",
           "         \tbuf[0] = (chars_read == 0 ? -1 : buf[0]);",
           "         }",
           "      \treturn cur = buf[buf_pos++];",
           "      }",
           "",
           "   \tinline void tie(int) { }",
           "",
           "   \tinline explicit operator bool() {",
           "      \treturn cur != -1;",
           "      }",
           "",
           "   \tinline static bool is_blank(char c) {",
           "      \treturn c <= ' ';",
           "      }",
           "",
           "   \tinline bool skip_blanks() {",
           "      \twhile (is_blank(cur) && cur != -1) {",
           "         \tget_char();",
           "         }",
           "      \treturn cur != -1;",
           "      }",
           "",
           "   \tinline FastInput &operator>>(char &c) {",
           "      \tskip_blanks();",
           "      \tc = cur;",
           "      \treturn *this;",
           "      }",
           "",
           "   \tinline FastInput &operator>>(string &s) {",
           "      \tif (skip_blanks()) {",
           "         \ts.clear();",
           "         \tdo {",
           "            \ts += cur;",
           "            } while (!is_blank(get_char()));",
           "         }",
           "      \treturn *this;",
           "      }",
           "",
           "   \ttemplate <typename T>",
           "   \tinline FastInput &read_integer(T &n) {",
           "         // unsafe, doesn't check that characters are actually digits",
           "      \tn = 0;",
           "      \tif (skip_blanks()) {",
           "         \tint sign = +1;",
           "         \tif (cur == '-') {",
           "            \tsign = -1;",
           "            \tget_char();",
           "            }",
           "         \tdo {",
           "            \tn += n + (n << 3) + cur - '0';",
           "            } while (!is_blank(get_char()));",
           "         \tn *= sign;",
           "         }",
           "      \treturn *this;",
           "      }",
           "",
           "   \ttemplate <typename T>",
           "   \tinline typename enable_if<is_integral<T>::value, FastInput &>::type operator>>(T &n) {",
           "      \treturn read_integer(n);",
           "      }",
           "",
           "#if !defined(_WIN32) || defined(_WIN64)",
           "   \tinline FastInput &operator>>(__int128 &n) {",
           "      \treturn read_integer(n);",
           "      }",
           "#endif",
           "",
           "   \ttemplate <typename T>",
           "   \tinline typename enable_if<is_floating_point<T>::value, FastInput &>::type operator>>(T &n) {",
           "         // not sure if really fast, for compatibility only",
           "      \tn = 0;",
           "      \tif (skip_blanks()) {",
           "         \tstring s;",
           "            (*this) >> s;",
           "         \tsscanf(s.c_str(), \"%lf\", &n);",
           "         }",
           "      \treturn *this;",
           "      }",
           "} fast_input;",
           "",
           "#define cin fast_input"
       ],
       "description": "fastInput"
   },
   "fastOutput": {
       "prefix": "fastOutput",
       "body": [
           "",
           "static struct FastOutput {",
           "   \tstatic constexpr int BUF_SIZE = 1 << 20;",
           "   \tchar buf[BUF_SIZE];",
           "   \tsize_t buf_pos = 0;",
           "   \tstatic constexpr int TMP_SIZE = 1 << 20;",
           "   \tchar tmp[TMP_SIZE];",
           "   \tFILE *out = stdout;",
           "",
           "   \tinline void put_char(char c) {",
           "      \tbuf[buf_pos++] = c;",
           "      \tif (buf_pos == BUF_SIZE) {",
           "         \tfwrite(buf, 1, buf_pos, out);",
           "         \tbuf_pos = 0;",
           "         }",
           "      }",
           "",
           "      ~FastOutput() {",
           "      \tfwrite(buf, 1, buf_pos, out);",
           "      }",
           "",
           "   \tinline FastOutput &operator<<(char c) {",
           "      \tput_char(c);",
           "      \treturn *this;",
           "      }",
           "",
           "   \tinline FastOutput &operator<<(const char *s) {",
           "      \twhile (*s) {",
           "         \tput_char(*s++);",
           "         }",
           "      \treturn *this;",
           "      }",
           "",
           "   \tinline FastOutput &operator<<(const string &s) {",
           "      \tfor (int i = 0; i < (int)s.size(); i++) {",
           "         \tput_char(s[i]);",
           "         }",
           "      \treturn *this;",
           "      }",
           "",
           "   \ttemplate <typename T>",
           "   \tinline char *integer_to_string(T n) {",
           "         // beware of TMP_SIZE",
           "      \tchar *p = tmp + TMP_SIZE - 1;",
           "      \tif (n == 0) {",
           "            *--p = '0';",
           "         } else {",
           "         \tbool is_negative = false;",
           "         \tif (n < 0) {",
           "            \tis_negative = true;",
           "            \tn = -n;",
           "            }",
           "         \twhile (n > 0) {",
           "               *--p = (char)('0' + n % 10);",
           "            \tn /= 10;",
           "            }",
           "         \tif (is_negative) {",
           "               *--p = '-';",
           "            }",
           "         }",
           "      \treturn p;",
           "      }",
           "",
           "   \ttemplate <typename T>",
           "   \tinline typename enable_if<is_integral<T>::value, char *>::type stringify(T n) {",
           "      \treturn integer_to_string(n);",
           "      }",
           "",
           "#if !defined(_WIN32) || defined(_WIN64)",
           "   \tinline char *stringify(__int128 n) {",
           "      \treturn integer_to_string(n);",
           "      }",
           "#endif",
           "",
           "   \ttemplate <typename T>",
           "   \tinline typename enable_if<is_floating_point<T>::value, char *>::type stringify(T n) {",
           "      \tsprintf(tmp, \"%.17f\", n);",
           "      \treturn tmp;",
           "      }",
           "",
           "   \ttemplate <typename T>",
           "   \tinline FastOutput &operator<<(const T &n) {",
           "      \tauto p = stringify(n);",
           "      \tfor (; *p != 0; p++) {",
           "         \tput_char(*p);",
           "         }",
           "      \treturn *this;",
           "      }",
           "} fast_output;",
           "",
           "#define cout fast_output"
       ],
       "description": "fastOutput"
   }
}